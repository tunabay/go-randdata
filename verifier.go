// Copyright (c) 2020 Hirotsuna Mizuno. All rights reserved.
// Use of this source code is governed by the MIT license that can be found in
// the LICENSE file.

package randdata

import (
	"bytes"
	"fmt"
	"io"
	"math/rand"
	"os"
	"sync"

	"github.com/tunabay/go-infounit"
)

// Verifier represents a verifier that verifies the byte sequence generated by
// Reader. Verification requires a Verifier with the same parameters, data type,
// random seed and size, as Reader that generates the target data. The byte
// sequence is verified by writing it to Verifier. If incorrect data is written,
// the writing will fail and an error will be returned. Verifier implements the
// Writer, StringWriter, ByteWriter, and ReaderFrom interfaces in the
// package io. There is also ReadFromFile method to verify data from a file.
// Whichever method is used, the same validation is performed. Note that wrong
// bytes and extra bytes than expected are verified on write, but shorter data
// length is not verified on write but on close. Therefore, after writing all
// the data to Verifier, be sure to call Close to verify that enough data was
// written.
type Verifier struct {
	dType   Type               // data type
	seed    int64              // random seed for data generation
	size    infounit.ByteCount // data size
	written infounit.ByteCount // number of bytes already written
	datRnd  *rand.Rand         // random generator for data
	gen     Generator
	buf     []byte // data currently being verified
	mu      sync.Mutex
}

// NewVerifier creates a Verifier with parameters. It is preferable to use
// Reader.Verifier(), which requires no parameters, if possible.
func NewVerifier(dType Type, seed int64, size infounit.ByteCount) *Verifier {
	v := &Verifier{
		dType:  dType,
		seed:   seed,
		size:   size,
		datRnd: rand.New(rand.NewSource(seed)),
	}
	switch dType {
	case Zero:
		v.gen = newZeroGenerator()
	case Binary:
		v.gen = newBinaryGenerator()
	case Text:
		v.gen = newTextGenerator()
	default:
		// unexpected type is treated as Binary type
		v.gen = newBinaryGenerator()
	}
	return v
}

// NewVerifierWithGenerator creates a new Verifier with a custom Generator.
// It is preferable to use Reader.Verifier() if possible.
func NewVerifierWithGenerator(gen Generator, seed int64, size infounit.ByteCount) *Verifier {
	return &Verifier{
		dType:  Custom,
		seed:   seed,
		size:   size,
		datRnd: rand.New(rand.NewSource(seed)),
		gen:    gen,
	}
}

// TODO: func NewVerifierFromSignature(sig string) (*Verifier, error)

// prepareNext generates the following pseudo-random byte sequence. This is
// called when the buffer is empty.
func (v *Verifier) prepareNext() error {
	buf, err := v.gen.Gen(v.datRnd, v.written, v.size-v.written)
	if err != nil {
		return err
	}
	v.buf = buf
	return nil
}

// Write writes the byte sequence to be verified to Verifier and returns the
// number of bytes written and the error. This implements the Writer interface
// in the package io. It returns an UnexpectedBytesError if incorrect data is
// written, and a TrailingExtraBytesError if the data is longer than expected.
// To verify if the data is shorter than expected, Close should be called after
// writing all the data.
func (v *Verifier) Write(p []byte) (int, error) {
	writeLen := len(p)
	if writeLen == 0 {
		return 0, nil
	}

	v.mu.Lock()
	defer v.mu.Unlock()

	if v.size <= v.written {
		v.written += infounit.ByteCount(writeLen)
		e := &TrailingExtraBytesError{
			ExpectedLen:   v.size,
			WrittenLen:    v.written,
			AcceptedBytes: nil,
			ExtraBytes:    make([]byte, writeLen),
		}
		copy(e.ExtraBytes, p)
		return 0, e
	}

	var accBytes, extBytes []byte
	if v.size < v.written+infounit.ByteCount(writeLen) {
		writeLen = int(v.size - v.written)
		accBytes = p[:writeLen]
		extBytes = p[writeLen:]
	}

	remLen := writeLen
	curSrc := p
	for {
		if len(v.buf) == 0 {
			if err := v.prepareNext(); err != nil {
				return writeLen - remLen, err
			}
		}
		n := len(v.buf)
		if remLen <= n {
			exBytes := v.buf[:remLen]
			wrBytes := curSrc[:remLen]
			if !bytes.Equal(exBytes, wrBytes) {
				e := &UnexpectedBytesError{
					Pos:           v.written,
					ExpectedBytes: make([]byte, len(exBytes)),
					WrittenBytes:  make([]byte, len(wrBytes)),
				}
				copy(e.ExpectedBytes, exBytes)
				copy(e.WrittenBytes, wrBytes)
				return writeLen - remLen, e
			}
			v.written += infounit.ByteCount(remLen)
			v.buf = v.buf[remLen:]
			break
		}

		exBytes := v.buf
		wrBytes := curSrc[:n]
		if !bytes.Equal(exBytes, wrBytes) {
			e := &UnexpectedBytesError{
				Pos:           v.written,
				ExpectedBytes: make([]byte, len(exBytes)),
				WrittenBytes:  make([]byte, len(wrBytes)),
			}
			copy(e.ExpectedBytes, exBytes)
			copy(e.WrittenBytes, wrBytes)
			return writeLen - remLen, e
		}

		curSrc = curSrc[n:]
		v.written += infounit.ByteCount(n)
		remLen -= n
		v.buf = nil
	}

	if 0 < len(extBytes) {
		v.written += infounit.ByteCount(len(extBytes))
		e := &TrailingExtraBytesError{
			ExpectedLen:   v.size,
			WrittenLen:    v.written,
			AcceptedBytes: make([]byte, len(accBytes)),
			ExtraBytes:    make([]byte, len(extBytes)),
		}
		copy(e.AcceptedBytes, accBytes)
		copy(e.ExtraBytes, extBytes)
		return writeLen, e
	}

	return writeLen, nil
}

// Close informs Verifier that writing of all data is complete. If the expected
// length of data has not been written, a NotEnoughBytesError will be returned.
func (v *Verifier) Close() error {
	if v.written < v.size {
		return &NotEnoughBytesError{
			ExpectedLen: v.size,
			WrittenLen:  v.written,
		}
	}
	return nil
}

// ReadFromFile verifies the contents of the file specified by path. It does not
// close Verifier automatically, so it is possible to combine it with other
// writing methods and/or to call it multiple times. To verify if the data is
// shorter than expected, Close should be called after writing all the data.
func (v *Verifier) ReadFromFile(path string) (int64, error) {
	f, err := os.Open(path)
	if err != nil {
		return 0, err
	}
	defer f.Close()
	return v.ReadFrom(f)
}

// ReadFrom reads and verifies data from r until io.EOF or error. It does not
// close Verifier automatically, so it is possible to combine it with other
// writing methods and/or to call it multiple times. To verify if the data is
// shorter than expected, Close should be called after writing all the data.
func (v *Verifier) ReadFrom(r io.Reader) (int64, error) {
	const bufSize = 8192
	var rLen int64
	buf := make([]byte, bufSize)
	for {
		rn, rErr := r.Read(buf)
		rLen += int64(rn)
		var wErr error
		if 0 < rn {
			_, wErr = v.Write(buf[:rn])
		}
		if rErr != nil {
			if rErr == io.EOF {
				return rLen, wErr
			}
			if wErr != nil {
				return rLen, fmt.Errorf("%w, with %v", rErr, wErr)
			}
			return rLen, rErr
		}
		if wErr != nil {
			return rLen, wErr
		}
	}
}

// WriteString verifies the contents of the string s. This implements the
// StringWriter interface in the package io.
func (v *Verifier) WriteString(s string) (int, error) {
	return io.WriteString(v, s)
}

// WriteByte verifies a single byte c. This implements the ByteWriter interface
// in the package io.
func (v *Verifier) WriteByte(c byte) error {
	_, err := v.Write([]byte{c})
	return err
}
