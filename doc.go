// Copyright (c) 2020 Hirotsuna Mizuno. All rights reserved.
// Use of this source code is governed by the MIT license that can be found in
// the LICENSE file.

/*
Package randdata provides a mechanism for unit testing to generate and verify
reproducible pseudo-random byte sequences.

Reader is the pseudo-random byte sequence generator. It implements the io.Reader
interface and can be Read the generated byte sequence. Verifier is the Reader
companion object that implements the io.Writer interface. It verifies that the
data written is exactly the same as the byte sequence generated by the Reader.

It is designed for unit testing of programs that process data from files or
networks and is used to verify that the processed data is not corrupted.

	// 5 MB pseudo-random byte sequence, using random seed 123
	r := randdata.New(randdata.Binary, 123, 5000000)

	// paired verifier
	v := r.NewVerifier()

	// read and veriry data
	buf := make([]byte, 256)
	for {
		n, err := r.Read(buf)
		if 0 < n {
			if _, err := v.Write(buf[:n]); err != nil {
				fmt.Println(err)
				break
			}
		}
		if err != nil {
			if err != io.EOF {
				fmt.Println(err)
			}
			break
		}
	}

	// verify that written data is enough
	if err := v.Close(); err != nil {
		fmt.Println(err)
	}

	fmt.Println("Read:", r.TotalRead())

The Reader also generates "jitter" to reading operation. In the above example,
calling Read method with the 256 bytes buffer returns randomly shorter written
length. While the Read method of the io.Reader interface can return shorter
length than passed buffer, program should be able to handle that. If the program
can not handle this behavior, it should use bufio.Reader, io.ReadFull, or
ioutil.ReadAll.
*/
package randdata
